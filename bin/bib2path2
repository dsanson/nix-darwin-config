#!/usr/bin/env bash
set -o errexit
set -o nounset
set -o pipefail

# TODO: rewrite this, probably not in bash, and separate out query options from output options.
#
# -   Should be possible to search by key or by title or by author or year or by all fields
# -   And then return a list of keys, paths, zotero links, a formatted bibliography, or json or yaml
# -   Probably also separate option to specify preferred filetype for paths and links: 
#     -   documents: pdf, epub, djvu
#     -   notes
#     -   images: jpg, png, etc.
#     -   all or first or most recent or...

# reqs: sed, pandoc, grep, head, coreutils , jq

BIB=$HOME/d/research/zotero.json

mode="path"

while [[ "${1:-}" =~ ^-.* ]]; do
  case "${1:-}" in
    -p|--path)
      mode="path" #return file path
      shift
      ;;
    -z|--zotero)
      mode="zotero" #return zotero:// link
      shift
      ;;
    -b|--bibliography)
      mode="bib" #return formatted bibliographic entry
      shift
      ;;
    -j|--json)
      mode="json" #return json entry
      shift
      ;;
    -y|--yaml)
      mode="yaml" #return yaml entry
      shift
      ;;
    -r)
      mode="id_from_path" #return key given path
      shift
      ;;
    -s)
      mode="id_from_search" #return key given path
      shift
      ;;
    -ip)
      mode="imagepath" #return path to attached image
      shift
      ;;
    -i)
      mode="image" #return markdown formatted local link to image
      shift
      ;;
    *)
      break
      ;;
  esac
done

# if no further cli arguments, look to stdin
set -- "${@:-$(</dev/stdin)}"

# should select the first citekey in the input marked by '@'
# or, if there is no '@', then just the first word
key=$(sed 's/[^@]*@//;s/[]";,./\\() ].*//' <<< "${1:-}" | sed "s/'//g") 

# page=$(sed -E 's/.*@'"$key"',? ?\[?p?p?\.? ?([0-9]+).*/\1/' <<< "$1")
#
# opt=""
#
# if [[ $page =~ ^-?[0-9]+$ ]]; then
#   opt="--page $page"
# fi

if [[ "$mode" == "bib" ]]; then
  jq -r 'map(select(.id == "'"$key"'"))' "$BIB" \
     | pandoc -f csljson --citeproc -t markdown-citations | grep -v ':::'
fi

if [[ "$mode" == "path" ]]; then
  jq -r 'map(select(.id == "'"$key"'")) | .[].file' "$BIB" \
    | sed 's/;/\n/g' | grep -e '.pdf$' | head -n1
fi

if [[ "$mode" == "image" ]]; then
  # This doesn't really work. Should probably copy the image to a local folder and rewrite the path.
  jq -r 'map(select(.id == "'"$key"'")) | ("![" + .[].title +"](" + .[].file + ")")' "$BIB"
fi

if [[ "$mode" == "imagepath" ]]; then
  jq -r 'map(select(.id == "'"$key"'")) | .[].file' "$BIB" \
    | sed 's/;/\n/g' | grep -e '.jpg$' | head -n1
fi

if [[ "$mode" == "zotero" ]]; then
  jq -r 'map(select(.id == "'"$key"'")) | .[]."open-in-zotero"' "$BIB"
fi

if [[ "$mode" == "json" ]]; then
  jq -r 'map(select(.id == "'"$key"'"))' "$BIB"
fi

if [[ "$mode" == "yaml" ]]; then
  echo '---'
  jq -r 'map(select(.id == "'"$key"'"))' "$BIB" | yq -y
  echo '---'
fi

if [[ "$mode" == "id_from_path" ]]; then
  link="${1:-}"
  if [[ -f "$link" ]]; then
    link="$(readlink -m "$link")"
  fi
  jq -r '.[] | select(.file | test("'"$link"'")) | .id' "$BIB"
fi

if [[ "$mode" == "id_from_search" ]]; then
  query="$*"
  jq -r '.[] | select(. | tostring | test("'"$query"'"; "i")) | ( "@" + .id )' "$BIB"
fi


